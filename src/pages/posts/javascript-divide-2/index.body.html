<h1>JavaScript中用 >> 1 实现除以二的问题</h1>
<p>2023年10月14日 @新加坡</p>
<br />
<p>
  很多人喜欢用 x >> 1 的方式来替代Math.floor(x/2)。浏览器console里试试这个：
</p>
<code>(2147483647 >> 1) === Math.floor(2147483647 / 2)</code>
<p>是true，对不对？再试试这个：</p>
<code>(2147483648 >> 1) === Math.floor(2147483648 / 2)</code>
<p>怎么变成false了？分别看看两边都得到了什么值：</p>
<code
  >2147483648 >> 1<br />// -1073741824<br /><br />Math.floor(2147483648 / 2)<br />// 1073741824</code
>
<p>为什么2147483648 >> 1会变成负数？显然是因为这里发生了溢出。</p>
<p>
  JavaScript里 >> 和 <<
  操作符只能返回32位精度的整数，而正常的数字都是64位的双精度浮点数（其中有1位用来表示正负，11位用来表示exponent，52位用来表示mantissa。这也是为什么Number.MAX_SAFE_INTEGER等于2的53次幂减1）。
</p>
<p>
  上文的2147483648恰巧是2的31次幂。执行 >> 1
  时，这个数字会先被转换为32位整数，此时2147483648在二进制中已经是1后面31个零，共32位。然而在2's
  complement表示规则下，它的值代表-2147483648。此时再执行 >> 1 的操作，由于 >>
  会携带首位表示正负的位("sign-propagating right
  shift")，这个值就会变成1后面一个1再加个三十个0。这就是为何我们会得到-1073741824这个奇怪的结果。
</p>
<p>
  由于2147483648是一个远小于Number.MAX_SAFE_INTEGER（9007199254740991）的数，使用 >> 1 大概率会造成上文讲的溢出问题，所以各位还是老老实实用Math.floor(x/2)吧。
</p>
<p>
  有大聪明可能会反驳我说，既然问题出在sign-propagating right shift上，那用 >>> 是不是就解决问题了？显然不是的，它最多能确保到2的32次幂减1为止是正确的。一旦超过这个数就会继续出问题，因为毕竟32位整数的表示范围就那么多。
</p>